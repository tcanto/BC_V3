#include "general.h"
#include "symTable.h"

int lex();
int charClass;
int token;
int nextToken;

/* expr
   Parses strings in the language generated by the rule:
   <expr> -> <term> {(+ | -) <term>}
 */
int expr()
{
   /* declare local variables */
   int var, var2;

   /* Parse the first term */
   var = term();

   /* As long as the next token is + or -, get
      the next token and parse the next term */
   while (nextToken == ADD_OP || nextToken == SUB_OP)
   {
      if (lexeme[0] == '+')
      {
         lex();
         var2 = term();
         var += var2;
      }
      else if (lexeme[0] == '-')
      {
         lex();
         var2 = term();
         var -= var2;
      }
   }
   return var;

} /* End of function expr */

/* term
 *  Parses strings in the language generated by the rule:
 *  <term> -> <factor> {(* | / | %) <factor>)
 */
int term()
{
   int var, var2;
   /* Parse the first factor */
   var = expo();
   /* As long as the next token is * or /, get the
      next token and parse the next factor */
   while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
   {
      if (lexeme[0] == '*')
      {
         lex();
         var2 = expo();
         var *= var2;
      }
      else if (lexeme[0] == '/')
      {
         lex();
         var2 = expo();
         var /= var2;
      }
      else if (lexeme[0] == '%')
      {
         lex();
         var2 = expo();
         var %= var2;
      }
   }
   return var;
} /* End of function term */

/* expo
 * Parses strings in the language generated by the rule:
 *   <expo> -> ^
 */
int expo()
{
   int var, var2;

   var = factor();

   while (nextToken == EXPO_OP)
   {
      if (lexeme[0] == '^')
      {
         lex();
         var2 = factor();
         var = pow(var, var2);
      }
   }

   return var;
}

/* factor
 * Parses strings in the language generated by the rule:
 *   <factor> -> id | int_constant | ( <expr> )
 */
int factor()
{
   VALUE var;
   Symbol_ptr identifier;
   /* Determine which RHS */
   if (nextToken == INT_LIT)
   {
      var.ivalue = atoi(lexeme);
      /* Get the next token */
      lex();
   }
   else if (nextToken == IDENT)
   {
      identifier = table.lookup(lexeme);
      var.ivalue = identifier->getval().ivalue;
      lex();
   }

   /* If the RHS is ( <expr> ), call lex to pass over the left 
      parenthesis, call expr and check for the right parenthesis */
   else if (nextToken == LEFT_PAREN)
   {
      lex();
      var.ivalue = expr();
      if (nextToken == RIGHT_PAREN)
         lex();
      else
         error("Right without left paren");
   }
   else
   {
      /* It was not an id, an integer literal, or a left
       parenthesis */
      error("expected an id, integer, or a left paren");
   } /* End of else */
   return var.ivalue;
} /* End of function factor */

/* stmt
 * Parses strings in the language generated by the rule:
 *   <stmt> -> <id> = <expr> | <expr> | DUMP | QUIT
 */
int stmt()
{
   Symbol_ptr identifier;
   VALUE var;
   if (nextToken == IDENT)
   {
      identifier = table.lookup(lexeme);
      lex();
      if (nextToken == ASSIGN_OP)
      {
         lex();
         var.ivalue = expr();
         identifier->putval(var);
         cout << "\t" << identifier->getid() << " = " << identifier->getval().ivalue << endl;
      }
   }
   else if (nextToken == QUIT)
   {
      cout << "bye!" << endl;
      exit(0);
   }
   else if (nextToken == DUMP)
   {
      table.dump_table();
   }
   else
   {
      var.ivalue = expr();
      cout << "\t= " << var.ivalue << endl;
   }
   return var.ivalue;
}

/* stmt_list
 * Parses strings in the language generated by the rule:
 *   <stmt_list> -> <stmt> NEWLINE | <stmt_list> <stmt> NEWLINE
 */
int stmt_list()
{
   int var;
   var = stmt();

   return var;
}

void error(const char *message)
{
   printf("Error: %s\n", message);
}