#include "general.h"
#include "symTable.h"

int lex();
int charClass;
int token;
int nextToken;
int mpass1 = 1, mpass2 = 1;
int pass = 1;

/* stmt_list
 * Parses strings in the language generated by the rule:
 *   <stmt_list> -> <stmt> NEWLINE | <stmt_list> <stmt> NEWLINE
 */
int stmt_list()
{
   int var;
   var = stmt();
   return var;
}

/* stmt
 * Parses strings in the language generated by the rule:
 *   <stmt> -> <id> = <expr> | <expr> | DUMP | QUIT
 */
int stmt()
{
   Symbol_ptr identifier, identifier2;
   VALUE var, var2;
   int intLIT;
   /*handles identifiers*/
   if (nextToken == IDENT)
   {
      identifier = table.lookup(lexeme);
      lex();
      /*assigns value to id*/
      if (nextToken == ASSIGN_OP)
      {
         lex();
         var.ivalue = expr();
         identifier->putval(var);
         cout << "\t" << identifier->getid()
              << " = " << identifier->getval().ivalue << endl;
      }
      /* handles id operations */
      else if (nextToken == ADD_OP || nextToken == SUB_OP ||
               nextToken == MULT_OP || nextToken == DIV_OP ||
               nextToken == MOD_OP || nextToken == EXPO_OP)
      {
         char op = lexeme[0];
         lex();
         var.ivalue = identifier->getval().ivalue;
         /* handles id OP id */
         if (nextToken == IDENT)
         {
            identifier2 = table.lookup(lexeme);
            var2.ivalue = identifier2->getval().ivalue;
            if (op == '+')
               var.ivalue += var2.ivalue;
            else if (op == '-')
               var.ivalue += var2.ivalue;
            else if (op == '*')
               var.ivalue *= var2.ivalue;
            else if (op == '/')
               var.ivalue /= var2.ivalue;
            else if (op == '%')
               var.ivalue %= var2.ivalue;
            else if (op == '^')
               var.ivalue = pow(var.ivalue, var2.ivalue);
         }
         /* handles id OP INT_LIT */
         else if (nextToken == INT_LIT)
         {
            intLIT = expr();
            if (op == '+')
               var.ivalue += intLIT;
            else if (op == '-')
               var.ivalue += intLIT;
            else if (op == '*')
               var.ivalue *= intLIT;
            else if (op == '/')
               var.ivalue /= intLIT;
            else if (op == '%')
               var.ivalue %= intLIT;
            else if (op == '^')
               var.ivalue = pow(var.ivalue, intLIT);
         }
         cout << "\t= " << var.ivalue << endl;
      }
      /* handles getting value of variable */
      else
      {
         var.ivalue = identifier->getval().ivalue;
      }
   }
   /* handles quit */
   else if (nextToken == QUIT)
   {
      cout << "bye!" << endl;
      exit(0);
   }
   /* handles dump */
   else if (nextToken == DUMP)
   {
      table.dump_table();
   }
   /* handles INT_LIT*/
   else
   {
      var.ivalue = expr();
      cout << "\t= " << var.ivalue << endl;
   }
   return var.ivalue;
}

/* expr
   Parses strings in the language generated by the rule:
   <expr> -> <term> {(+ | -) <term>}
 */
int expr()
{
   /* declare local variables */
   int var, var2;

   /* Parse the first term */
   var = term();

   /* As long as the next token is + or -, get
      the next token and parse the next term */
   while (nextToken == ADD_OP || nextToken == SUB_OP)
   {
#ifdef DEBUG
      cout << "===== expr pass " << pass << " =====" << endl;
      cout << "lexeme: " << lexeme[0] << endl;
      cout << "token: " << token << endl;
      cout << "=======================" << endl;
      pass++;
#endif
      if (lexeme[0] == '+')
      {
         lex();
         var2 = term();
         var += var2;
      }
      else if (lexeme[0] == '-')
      {
         lex();
         var2 = term();
         var -= var2;
      }
   }
   return var;

} /* End of function expr */

/* term
 *  Parses strings in the language generated by the rule:
 *  <term> -> <unary> {(* | / | %) <unary>)
 */
int term()
{
   int var, var2;
   /* Parse the first factor */
   var = unary();
   /* As long as the next token is *, /, or %, get the
      next token and parse the next factor */
   while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
   {
      if (lexeme[0] == '*')
      {
         lex();
         var2 = unary();
         var *= var2;
      }
      else if (lexeme[0] == '/')
      {
         lex();
         var2 = unary();
         var /= var2;
      }
      else if (lexeme[0] == '%')
      {
         lex();
         var2 = unary();
         var %= var2;
      }
   }
   return var;
} /* End of function term */

/* unary
 * Parses strings in the language generated by the rule:
 *   <unary> -> - <expo>
 */
int unary()
{
   int var;
   var = expo();
#ifdef DEBUG
   cout << "===== minus pass1 " << mpass1 << " =====" << endl;
   cout << "lexeme: " << lexeme[0] << endl;
   cout << "token: " << token << endl;
   cout << "========================" << endl;
   mpass1++;
#endif
   while (nextToken == SUB_OP && token != INT_LIT && token != IDENT)
   {
#ifdef DEBUG
      cout << "===== minus pass2 " << mpass2 << " =====" << endl;
      cout << "lexeme: " << lexeme[0] << endl;
      cout << "token: " << token << endl;
      cout << "========================" << endl;
      mpass2++;
#endif

      lex();
      var = expo();
      var = -var;
   }

   return var;
}

/* expo
 * Parses strings in the language generated by the rule:
 *   <expo> -> <factor> ^ <factor>
 */
int expo()
{
   int var, var2;

   var = factor();

   while (nextToken == EXPO_OP)
   {
      if (lexeme[0] == '^')
      {
         lex();
         var2 = factor();
         var = pow(var, var2);
      }
   }

   return var;
}

/* factor
 * Parses strings in the language generated by the rule:
 *   <factor> -> id | int_constant | ( <expr> )
 */
int factor()
{
   VALUE var;
   Symbol_ptr identifier;
   /* Determine which RHS */
   if (nextToken == INT_LIT)
   {
      var.ivalue = atoi(lexeme);
      /* Get the next token */
      lex();
   }
   else if (nextToken == IDENT)
   {
      identifier = table.lookup(lexeme);
      var.ivalue = identifier->getval().ivalue;
      lex();
   }

   /* If the RHS is ( <expr> ), call lex to pass over the left 
      parenthesis, call expr and check for the right parenthesis */
   else if (nextToken == LEFT_PAREN)
   {
      lex();
      var.ivalue = expr();
      if (nextToken == RIGHT_PAREN)
         lex();
      else
         error("Right without left paren");
   }
   else if (nextToken == SUB_OP)
   {
      return var.ivalue;
   }
   else
   {
      /* It was not an id, an integer literal, or a left
       parenthesis */
      error("expected an id, integer, or a left paren");
   } /* End of else */
   return var.ivalue;
} /* End of function factor */

void error(const char *message)
{
   printf("Error: %s\n", message);
}